{"posts":[{"title":"Shell学习记录","content":"1. Shell入门 创建shell文件 使用文本编辑器来创建一个shell文件，注意在第一行指定使用的编辑器。 #!/bin/bash 一般#代表注释，但是在第一行#!代表指定编辑器。 执行shell 执行shell有两种方式，一种是添加到path目录中，一种是sh指定路径下的shell文件。当shell文件的权限不足时，应该使用chmod来修改对应的权限。 使用shell输出语句 正常情况下直接在shell里面使用echo命令即可，但是如果有时候要输出引号，则需要在外面再用一层引号将其包围，不然可能会导致误判。 2.shell中的变量 注意事项 shell的赋值语句中，=两边是不允许有空格的！一定要注意！ 自定义变量 直接变量名=变量值即可 var1=10 调用变量 调用变量要使用$变量，否则shell不知道你是要输出名字还是变量。 echo $var1 #10 var2=$var1 echo $var2 #10 echo var2 #var2 echo &quot;var1 is&quot;$var1 输出命令 有时候需要将命令获取的内容输出，比如需要获取date的内容，此时只需要使用反引号字符(`)或者$()格式即可 一般情况下都将命令赋予变量，最后再输出变量即可。 echo `date` #输出date命令的内容 date=`date` echo date #同上效果 date2=$(date +%y%m%d%) echo date2 #同上效果 3.内容重定向 文件覆盖 shell中可以直接使用&gt;来覆盖文件 command &gt; outputfile 如上使用一定的命令就可以将内容覆盖到outputfile中。 PS:此处有一个小技巧，可以直接使用&gt;来创建文件 &gt; newfile 因为没有内容重定向，所以此处会创建一个空的新文件newfile 文件追加 文件追加命令使用&gt;&gt;来实现，其用法类似&gt;，只是效果是在文件的最后一行添加内容而不是覆盖内容。 added &gt;&gt; oldfile 命令内容追加 命令内容追加可以理解为把文件里面的内容添加给命令，此处使用和文件夹方向相反的符号，即&lt;。 wc &lt; test 如上，将test文件的内容传给wc，wc会将文本的行数、词数和字节数进行输出。 管道 如上文所说的重定向都是需要借助文件实现的重定向，但是有时候若想要将命令的内容传递给命令，使用上文的方式只能将命令获取的内容传递到文件中去，然后再从文件中获取输出给下一个命令，这样的过程则较为繁琐，有没有一种方式能够直接将命令的内容传递给命令呢？ 这正是管道。 command1 | command2 如上诉代码，可以将command1获取的命令传递给command2 管道是打通两个命令之间的符号，是的多个命令可以组合起来灵活使用。 rpm -qa | sort &gt; rpm.list 4.数学运算 由于expr命令使用较为繁杂，此处只介绍使用方括号的方式来进行数学运算的方法。 中括号 如下，因为linux中直接使用运算符有时候会出现各种各样的问题，所以我们直接用中括号包起来，可以避免所有奇怪的问题。 var1=$[1+5] echo $var1 #6 var2=$[$var1 * 2] echo $var2 #12 浮点问题的处理 虽然中括号解决了数学运算符的识别问题，但是这种计算只适用于非浮点的运算，如果运算存在浮点是无法准确地计算出来的。 var1=100 var2=45 var3=$[var1/$var2] echo var3 #2 为了解决浮点运算的问题我们使用bc方法。如下所示： bc 12 * 5.4 64.8 使用bc相对于进入到一个计算器的页面，在里面输入需要计算的数学运算式子即可。 可是我不可能说每一次都进入到bc的运算界面进行运算，所以此处可以使用管道将内容传递给bc计算器。 使用管道传递给bc var1=$(echo &quot;scale=4; 3.44/5&quot; | bc) echo var1 #.6880 如上式子的意思是将指定的内容传递给bc同时设置结果的小数位为4，神奇的就是要通过echo的方式将内容传递给bc，同时在echo中知道你scale的值，用；进行分割刻度与式子。 使用注释传递给bc 虽然使用管道也可以实现浮点的运算，但是如果有时候式子比较多，再使用管道进行数据的传输则会较为麻烦。所以此处还有另外一种方法来进行内容的传递 $ cat test12 #!/bin/bash var1=10.46 var2=43.67 var3=33.2 var4=71 var5=$(bc &lt;&lt; EOF scale = 4 a1 = ( $var1 * $var2) b1 = ($var3 * $var4) a1 + b1 EOF ) echo The final answer for this mess is $var5 $ 此处可以发现，我们还可以通过bc赋值给变量。 5.test命令 有时候比如要判断文件是否可读，需要使用命令进行判断，这时候就需要用到test指令了。 一帮使用中括号将需要test的内容围起来进行判断即可，无需每次都使用test指令。 if [$value -gt 5] then ... 三种比较 数字比较 字符串比较 使用字符串要注意字符的转义，比如&gt;会被识别为文件重定向，需要在前面添加转移斜杆即&gt; 文件比较 复合条件 可以使用符合条件来结合多个条件进行联合比较。格式如下： [condition1] &amp;&amp; [condition2] 两个条件同时满足 [condition1] || [condition2] 满足其中一个条件 6.if-else的高级特性 使用双括号 ((expression)) 通过使用双括号，可以在其中使用一些自增、自减等操作，详细的使用表格如下所示： 在代码中的使用方法如下： $ cat test23.sh #!/bin/bash # using double parenthesis # val1=10 # if (( $val1 ** 2 &gt; 90 )) then (( val2 = $val1 ** 2 )) echo &quot;The square of $val1 is $val2&quot; fi $ $ ./test23.sh The square of 10 is 100 $ 使用双方括号 双方括号可以用来匹配正则表达式，以后在双方括号中输入想要匹配的正则表达式。 [[]] 比如： if [[$USER == r*]] then echo &quot;Hello $USER&quot; case语句 case语句可以使得代码看起来更加清晰明了，通过以下的两个对比例子进行相应的展示。 使用if： $ cat test25.sh #!/bin/bash # looking for a possible value # if [ $USER = &quot;rich&quot; ] then echo &quot;Welcome $USER&quot; echo &quot;Please enjoy your visit&quot; elif [ $USER = &quot;barbara&quot; ] then echo &quot;Welcome $USER&quot; echo &quot;Please enjoy your visit&quot; elif [ $USER = &quot;testing&quot; ] then echo &quot;Special testing account&quot; elif [ $USER = &quot;jessica&quot; ] then echo &quot;Do not forget to logout when you're done&quot; else echo &quot;Sorry, you are not allowed here&quot; fi $ $ ./test25.sh Welcome rich Please enjoy your visit $ 使用case： $ cat test26.sh #!/bin/bash # using the case command # case $USER in rich | barbara) echo &quot;Welcome, $USER&quot; echo &quot;Please enjoy your visit&quot;;; testing) echo &quot;Special testing account&quot;;; jessica) echo &quot;Do not forget to log off when you're done&quot;;; *) echo &quot;Sorry, you are not allowed here&quot;;; esac $ $ ./test26.sh Welcome, rich Please enjoy your visit $ ","link":"https://sugar940.github.io/post/shell-xue-xi-ji-lu/"},{"title":"回溯法合集二","content":"216.组合总和 III Leetcode / 力扣 Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] 从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtrapping(int n,int k,vector&lt;int&gt; &amp;path,int sum,int begin){ if(sum &gt; n){ return; } if(sum == n &amp;&amp; path.size() == k){ result.push_back(path); return; } //i &lt;= 9-(k-path.size())+1是精髓，k-path.size():还要放进去的数的个数 //如果for循环之后的元素个数不足我们需要的元素个数，那么停止搜索 for(int i = begin;i &lt;= 9-(k-path.size())+1 ;i++){ path.push_back(i); sum += i; backtrapping(n, k, path, sum,i+1); path.pop_back(); sum -= i; } } vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { backtrapping(n, k,path,0,1); return result; } }; 思路： 结束条件：总和为n并且子集合的长度和k相等，说明子集寻找完毕 递归条件：从begin开始运行到9-(k-path.size())+1，保证元素不重合，同时当循环之后的元素个数不足我们需要的元素的个数时，停止搜索。因为不能有重复的所以从i+1开始。 回溯：把加入的数组弹出去，开始新一轮 78.子集 Leetcode / 力扣 找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复 class Solution { public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtripping(vector&lt;int&gt;&amp; nums,vector&lt;int&gt; path,int begin){ if(path.size() &gt; nums.size()){ return; } result.push_back(path); for(int i = begin;i &lt; nums.size();i++){ path.push_back(nums[i]); backtripping(nums, path, i+1); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { backtripping(nums, path, 0); return result; } }; 思路： 每次遍历都把新情况存入数组中，每次递归都从新的数字开始。 90.子集 II Leetcode / 力扣 For example, If nums = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] class Solution { public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtripping(vector&lt;int&gt;&amp; nums,int begin,vector&lt;bool&gt;used){ result.push_back(path); for(int i = begin;i &lt; nums.size();i++){ //常用的去重代码，几乎每一题要去重都是用这个来去重的 if(i&gt;0&amp;&amp;nums[i] == nums[i-1] &amp;&amp; used[i-1] == false){ continue; }else{ used[i] = true; path.push_back(nums[i]); backtripping(nums, i+1,used); path.pop_back(); used[i] = false; } } } vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(),false); sort(nums.begin(),nums.end()); backtripping(nums,0,used); return result; } }; used[i-1]==true说明在同一树枝上有相同的，可以继续。 used[i-1]==false说明在同一树层上，但是同一树层上不允许有相同的，所以这个可以用来过滤不合理的成员。 131.分割回文串 Leetcode / 力扣 For example, given s = &quot;aab&quot;, Return [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ] class Solution { private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 void backtracking (const string&amp; s, int startIndex) { // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) { result.push_back(path); return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); } else { // 不是回文，跳过 continue; } backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经填在的子串 } } bool isPalindrome(const string&amp; s, int start, int end) { for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) { return false; } } return true; } public: vector&lt;vector&lt;string&gt;&gt; partition(string s) { result.clear(); path.clear(); backtracking(s, 0); return result; } }; 思路： 先写一个判定是否是回文的函数 把判断回文作为循环判定条件，是回文就存入，不是就往下接着递归。注意这里取的是一整个串。 37.解数独 Leetcode / 力扣 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 class Solution { private: bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; board.size(); i++) { // 遍历行 for (int j = 0; j &lt; board[0].size(); j++) { // 遍历列 if (board[i][j] != '.') continue; for (char k = '1'; k &lt;= '9'; k++) { // (i, j) 这个位置放k是否合适 if (isValid(i, j, k, board)) { board[i][j] = k; // 放置k if (backtracking(board)) return true; // 如果找到合适一组立刻返回 board[i][j] = '.'; // 回溯，撤销k } } return false; // 9个数都试完了，都不行，那么就返回false } } return true; // 遍历完没有返回false，说明找到了合适棋盘位置了 } bool isValid(int row, int col, char val, vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) { // 判断行里是否重复 if (board[row][i] == val) { return false; } } for (int j = 0; j &lt; 9; j++) { // 判断列里是否重复 if (board[j][col] == val) { return false; } } //保证从九宫格的左上角到右下角 //这样就不会弄错九宫格的判断 int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i &lt; startRow + 3; i++) { // 判断9方格里是否重复 for (int j = startCol; j &lt; startCol + 3; j++) { if (board[i][j] == val ) { return false; } } } return true; } public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { backtracking(board); } }; 判断： 是否同行 是否同列 是否同九宫格 判断通过 取新的数递归（注意是二维取数） 回溯 51.N皇后 Leetcode / 力扣 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 class Solution { private: vector&lt;vector&lt;string&gt;&gt; result; // n 为输入的棋盘大小 // row 是当前递归到***的第几行了 void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) { if (row == n) { result.push_back(chessboard); return; } for (int col = 0; col &lt; n; col++) { if (isValid(row, col, chessboard, n)) { // 验证合法就可以放 chessboard[row][col] = 'Q'; // 放置皇后 backtracking(n, row + 1, chessboard); chessboard[row][col] = '.'; // 回溯，撤销皇后 } } } bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) { int count = 0; // 检查列 for (int i = 0; i &lt; row; i++) { // 这是一个剪枝 if (chessboard[i][col] == 'Q') { return false; } } // 检查 45度角是否有皇后 for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) { if (chessboard[i][j] == 'Q') { return false; } } // 检查 135度角是否有皇后 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) { if (chessboard[i][j] == 'Q') { return false; } } return true; } public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { result.clear(); std::vector&lt;std::string&gt; chessboard(n, std::string(n, '.')); backtracking(n, 0, chessboard); return result; } }; 判断45度是否有皇后 判断135度是否有皇后 符合判断需求则往后取新的数 此题相当于对数独的其中一个九宫格简化求解。 ","link":"https://sugar940.github.io/post/hui-su-he-ji-er/"},{"title":"回溯法合集一","content":"17.数字键盘组合 Leetcode / 力扣 Input:Digit string &quot;23&quot; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. class Solution { public: void dfs(string &amp;digits,int index,unordered_map&lt;char,string&gt; phone,vector&lt;string&gt; &amp;ans,string &amp;member){ if(index == digits.size()){ ans.push_back(member); }else{ //按钮 char map_index = digits[index]; //取出当前按钮的内容 string temp = phone.find(map_index)-&gt;second; //遍历当前按钮的内容，和下一个按钮的内容拼凑到一起 for(int i = 0;i &lt; temp.size();i++){ //取出拼凑的字符 char a = temp[i]; //把当前字母拼凑到成员中 member.push_back(a); //继续像下一层进发 dfs(digits,index+1,phone,ans,member); //************注意要弹出刚刚插入的！！！因为这边要开始一个新的循环了！！********** member.pop_back(); } } } vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; ans; if(digits.size() == 0){ return ans; } string member; //把键盘录入 unordered_map&lt;char,string&gt; phone = { {'2',&quot;abc&quot;}, {'3',&quot;def&quot;}, {'4',&quot;ghi&quot;}, {'5',&quot;jkl&quot;}, {'6',&quot;mno&quot;}, {'7',&quot;pqrs&quot;}, {'8',&quot;tuv&quot;}, {'9',&quot;wxyz&quot;} }; dfs(digits,0,phone,ans,member); return ans; } }; 思路: 把每一个按键对应的字母先存入unordered_map中保存好 设置终止条件：当子成员的长度和按键的数量相等，即一组组合已经生成，即可存入总数组中。 设置递归条件：每次取一个字母，之后前往index+1，即下一个字母。 设置回溯：让总数组把最后一个字母弹出来，然后重新循环。即开始一个新的组合。 93.复原ip地址 Leetcode / 力扣 Given &quot;25525511135&quot;, return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. class Solution { public: vector&lt;string&gt;ans; void backtrace(string&amp; s,int cnt,int index,string&amp; str){ //标点符号超过3或者到达最后一位 if(cnt==4 || index==s.size() ){ //标点符号超过3并且到达最后一位则说明划分完成 if(cnt==4 &amp;&amp; index==s.size()) ans.push_back(str.substr(0,str.size()-1)); //若不是最后一位则不执行以上操作直接返回 return; } //打入三个小数点 for(int i=1;i&lt;=3;i++){ //如果越界则不执行 if(index+i&gt;s.size()) return; //如果起点是0，那么它只能单独成块，后面不能跟别的数字（即不含有前导0） if(s[index]=='0' &amp;&amp; i!=1) return; //如果取了3位，并且它们加起来超过255则返回 if(i==3 &amp;&amp; s.substr(index,i)&gt;&quot;255&quot;) return; //符合以上过滤规则则执行拼接 str+=s.substr(index,i); //拼接完成后再后面加一个. str.push_back('.'); //对后面的单词执行拼接 backtrace(s,cnt+1,index+i,str); //还原为上述回溯步骤之前 str = str.substr(0,str.size()-i-1); } } vector&lt;string&gt; restoreIpAddresses(string s) { string str =&quot;&quot;; backtrace(s,0,0,str); return ans; } }; 思路： 设置结束条件：当标点数超过三或者标点位置在最后则可以结束，当标点位置超过3且位于最后一位则把这组ip地址插入总数组中。 设置递归条件: 越界返回 0不和其他数字组合返回 3位合超过255返回 以上情况都不发生就循环递归 每次递归标点数+1，指针+1 设置回朔条件： 让str字符串最后以为消去，即只取字符串的0到长度str.size()-i-1位。（打点可能垮了几个字符所以要-i-1） 打点数变成cnt-1 79.单词搜索 Leetcode / 力扣 For example, Given board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = &quot;ABCCED&quot;, -&gt; returns true, word = &quot;SEE&quot;, -&gt; returns true, word = &quot;ABCB&quot;, -&gt; returns false. class Solution { public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { for(int i = 0; i &lt; board.size(); i++) for(int j = 0; j &lt; board[i].size(); j++) if(dfs(board,word,0,i,j)) return true; return false; } int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1}; //方向数组 bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word,int u,int x,int y) { if(board[x][y] != word[u]) return false; if(u == word.size() - 1) return true; char t = board[x][y]; board[x][y] = '.'; for(int i = 0; i &lt; 4; i++) { int a = x + dx[i], b = y + dy[i]; //出界或者走到已经搜索过的位置 if(a &lt; 0 || a &gt;= board.size() || b &lt; 0 || b &gt;= board[0].size() || board[a][b] == '.') continue; if(dfs(board,word,u+1,a,b)) return true; } board[x][y] = t; return false; } }; 思路： 设置结束条件： 遍历的块和目标块不一样返回false 遍历到最后一位，说明前面的都没有问题，返回true 没有返回数组说整个区块没有正确的组合，返回false。 设置递归： 延四个方向递归 出界返回或者遇到'.'返回false 正常继续往下递归，u+1(u记录遍历长度) 递归过的位置变成'.' 257.二叉树的所有路径 Leetcode / 力扣 1 / \\ 2 3 \\ 5 [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] class Solution { public: void construct_paths(TreeNode* root, string path, vector&lt;string&gt;&amp; paths) { //首先判断是否为空节点，因为是同时传的左右结点，都有为空的可能性,如果为空此处直接略过 if (root != nullptr) { //如果不为空则往后添加值 path += to_string(root-&gt;val); //判断是否为叶子结点，如果不是叶子结点则继续往下遍历 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) { // 当前节点是叶子节点 paths.push_back(path); // 把路径加入到答案中 } else { //不是叶子结点说明后面还有结点，最为加-&gt;并继续遍历 path += &quot;-&gt;&quot;; // 当前节点不是叶子节点，继续递归遍历 construct_paths(root-&gt;left, path, paths); construct_paths(root-&gt;right, path, paths); } } } vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; paths; construct_paths(root, &quot;&quot;, paths); return paths; } }; 思路： 设置递归条件 节点非空就递归 每次递归往path后插入结点的值 如果该结点非叶子结点，插入&quot;-&gt;&quot;，并且往左边和右边递归 如果为叶子结点：插入路径到数组中。 46.全排列 Leetcode / 力扣 [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; void backtrpping(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; passed,vector&lt;int&gt;&amp; path){ //如果已存入数组的大小和待排序数组的大小相等，则说明这一组数据排序完成 if(path.size() == nums.size()){ ans.push_back(path); return; } for(int i = 0;i &lt; nums.size();i++){ if(passed[i] == true){ continue; }else{ //如果这个点没有去过就进行标记并记录下来 passed[i] = true; path.push_back(nums[i]); backtrpping(nums, passed, path); //回溯 path.pop_back(); //这一步写的时候忽略了！ passed[i] = false; } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { //对vector数组进行赋值 vector&lt;bool&gt; passed(nums.size(),false); vector&lt;int&gt; path; backtrpping(nums, passed, path); return ans; } }; 结束条件：当子成员的长度和数组的长度一样，子成员插入数组中去。 递归条件： 没有去过这个点，则把这个点插入子成员，并且把这个点设置为true，传入下一层递归 最后记得把刚刚改变的路径还原 47.含有相同元素的全排列 Leetcode / 力扣 [1,1,2] have the following unique permutations: [[1,1,2], [1,2,1], [2,1,1]] 数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。 在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; void backtrpping(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; passed){ //如果已存入数组的大小和待排序数组的大小相等，则说明这一组数据排序完成 if(path.size() == nums.size()){ ans.push_back(path); return; } for(int i = 0;i &lt; nums.size();i++){ //此处的passed[i-1]为true或者false都可以 if(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; passed[i-1] == false){ continue; } //注意此处需要额外判断passed[i]是否为false，只有passed[i]为false时才执行以下步骤 if(passed[i] == false){ //如果这个点没有去过就进行标记并记录下来 passed[i] = true; path.push_back(nums[i]); backtrpping(nums, passed); //回溯 path.pop_back(); //这一步写的时候忽略了！ passed[i] = false; } } } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { //对vector数组进行赋值 sort(nums.begin(),nums.end()); vector&lt;bool&gt; passed(nums.size(),false); backtrpping(nums, passed); return ans; } }; 结束条件： 当子成员的大小和序列大小一样时把子成员存入数组中 递归条件： 首先要排除重复元素的干扰 //只要符合如图所示条件就跳过此次循环 //遇到相等的元素，并且 if(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; passed[i-1] == false){ continue; } 经过上述去重后判断该点是否之前经过，防止出现重复的数字，如果之前去过了跳过，没去过插入 回溯条件： 路径回溯 结果点回溯 ","link":"https://sugar940.github.io/post/hui-su-fa-he-ji-yi/"},{"title":"深度优先遍历合集","content":"695.查找最大连通面积 Leetcode / 力扣 [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 示例 1： 输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] 输出：6 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。 class Solution { public: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y){ if(x &lt; 0 || y &lt; 0 || x == grid.size() || y == grid[0].size() ||grid[x][y] == 0 ){ return 0; } int d_x[4] = {0,0,-1,1}; int d_y[4] = {1,-1,0,0}; int ans = 1; grid[x][y] = 0; for(int i =0;i &lt; 4;i++){ int new_x = x+d_x[i]; int new_y = y+d_y[i]; ans += dfs(grid,new_x,new_y); } return ans; } int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ans = 0; for(int i = 0;i &lt; grid.size();i++){ for(int j = 0;j &lt; grid[0].size();j++){ ans = max(ans,dfs(grid,i,j)); } } return ans; } }; 使用深度优先遍历对每一个地图块进行深度优先遍历，同时记录每一次遍历的最大值，最终返回最大值就是可以得到的最大块数。 200.岛屿数量 Leetcode / 力扣 Input: 11000 11000 00100 00011 Output: 3 class Solution { public: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y){ if(x &lt; 0 || y &lt; 0 || x == grid.size() || y == grid[0].size() || grid[x][y] == '0'){ return false; } int d_x[4] = {0,0,1,-1}; int d_y[4] = {1,-1,0,0}; grid[x][y] = '0'; for(int i = 0; i &lt; 4;i++){ int new_x = x+d_x[i]; int new_y = y+d_y[i]; dfs(grid,new_x,new_y); } return true; } int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int ans = 0; for(int i = 0;i &lt; grid.size();i++){ for(int j = 0; j &lt; grid[0].size();j++){ if(dfs(grid,i,j)){ ans++; } } } return ans; } }; 对每一格进行深度遍历，把遍历过的岛屿都变成海，同时进行计数，没填一个岛屿就进行加一，最终返回计数的总数即可。 547.省份数量 Leetcode / 力扣 Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2. class Solution { public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected, vector&lt;int&gt;&amp; visited, int provinces, int i) { for (int j = 0; j &lt; provinces; j++) { if (isConnected[i][j] == 1 &amp;&amp; !visited[j]) { visited[j] = 1; dfs(isConnected, visited, provinces, j); } } } int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { int provinces = isConnected.size(); vector&lt;int&gt; visited(provinces); int circles = 0; for (int i = 0; i &lt; provinces; i++) { if (!visited[i]) { dfs(isConnected, visited, provinces, i); circles++; } } return circles; } }; 对省份进行深度优先遍历，使用visited数组来记录已经访问过的省份。 130.被围绕的区域 Leetcode / 力扣 For example, X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X class Solution { public: int n, m; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) { if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || board[x][y] != 'O') { return; } board[x][y] = 'A'; dfs(board, x + 1, y); dfs(board, x - 1, y); dfs(board, x, y + 1); dfs(board, x, y - 1); } void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { n = board.size(); if (n == 0) { return; } m = board[0].size(); //遍历边界，把和边界相连的的O变为A for (int i = 0; i &lt; n; i++) { dfs(board, i, 0); dfs(board, i, m - 1); } for (int i = 1; i &lt; m - 1; i++) { dfs(board, 0, i); dfs(board, n - 1, i); } //遍历数组，把边界的A还原为X，把正常的O变为X。 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (board[i][j] == 'A') { board[i][j] = 'O'; } else if (board[i][j] == 'O') { board[i][j] = 'X'; } } } } }; 对于被围绕区域的筛查，首先可以把和边界相连的区域进行标记，之后再对剩余的区域进行深度优先遍历，使之变成x，之后再把之前标记过的元素还原为O即可。 417.太平洋和大西洋水流问题 Leetcode / 力扣 Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * Atlantic Return: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。 class Solution { private: vector&lt;int&gt; direction{-1, 0, 1, 0, -1}; void DFS(const vector&lt;vector&lt;int&gt;&gt;&amp; heights, vector&lt;vector&lt;bool&gt;&gt;&amp; canReach, int i, int j) { if (canReach[i][j]) return; canReach[i][j] = true; for (int k = 0; k &lt; 4; k++) { int p = i + direction[k]; int q = j + direction[k + 1]; if (p &gt;= 0 &amp;&amp; p &lt; heights.size() &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; heights[0].size() &amp;&amp; heights[p][q] &gt;= heights[i][j]) { DFS(heights, canReach, p, q); } } } public: vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { // 采用 DFS if (heights.empty() || heights[0].empty()) { return {}; } int m = heights.size(), n = heights[0].size(); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;bool&gt;&gt; canReachA (m, vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;bool&gt;&gt; canReachP (m, vector&lt;bool&gt;(n, false)); // can reach Atlantic for (int i = 0; i &lt; m; i++) { // 左边太平洋 DFS(heights, canReachA, i, 0); // 右边大西洋 DFS(heights, canReachP, i, n - 1); } for (int j = 0; j &lt; heights[0].size(); j++) { // 上边太平洋 DFS(heights, canReachA, 0, j); // 下边大西洋 DFS(heights, canReachP, m - 1, j); } // 找到都能到达的坐标 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (canReachA[i][j] &amp;&amp; canReachP[i][j]) { res.push_back({i, j}); } } } return res; } }; 直接考虑从高处往低处流的情况比较难考虑，因为水流既要满足大西洋又要满足太平洋，很难写出同时满足的判断代码，所以此题换一个角度进行考虑，逆向思维，反过来求解水往高处流，分别从大西洋和太平洋出发进行深度优先遍历，把可以到达的点都进行记录，最后取两个记录数组的交集就是既可以到达大西洋又可以到达太平洋的点。 ","link":"https://sugar940.github.io/post/shen-du-you-xian-bian-li-he-ji/"},{"title":"BFS广度有限搜索合集","content":"1091.计算在网格中从原点到特定点的最短路径长度 Leetcode / 力扣 [[1,1,0,1], [1,0,1,0], [1,1,1,1], [1,0,1,1]] 题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。 class Solution { public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { //起点为1则无法继续行进 if(grid[0][0] == 1){ return -1; } int ans = 1; //定义x和y对应的8个方向 int dirc[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{-1,1},{1,-1},{-1,-1}}; queue&lt;pair&lt;int,int&gt;&gt; q; q.emplace(0,0); //表示起点已经去过 grid[0][0] = 1; int n = grid.size(); //BFS模板写法 while(!q.empty()){ //遍历8个方向，去过的地方记为1 int m = q.size(); //即只要队列中存在元素就一直遍历下去 while(m--){ //取出队首元素 auto [x,y] = q.front(); q.pop(); //如果走到了终点则直接返回次数，因为最先到达终点的一定是最优解 if(x == n-1 &amp;&amp; y == n-1){ return ans; } for(int i =0; i &lt; 8; i++){ //x和y向八个方向分别移动 int nx = x + dirc[i][0]; int ny = y + dirc[i][1]; //如果发生越界则返回 if(nx &lt;0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) continue; if(grid[nx][ny] == 0){ //如果八个方向中有为0的点则记录进队列中，继续往八个方向扩散 q.emplace(nx,ny); //把访问过的点记为1 grid[nx][ny] = 1; } } } ans ++; } return -1; } }; 使用广度有限搜索同时遍历整个数组格子，最先到达终点的直接返回数值，返回的即是最短距离。 广度优先遍历使用队列进行遍历，把遍历的点录入队列，之后便会通过队列的顺序进行广度优先遍历。 279.组成整数的最小平方数 Leetcode / 力扣 For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。 要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。 class Solution { public: int numSquares(int n) { unordered_set&lt;int&gt; visited; queue&lt;int&gt; q{{0}}; int steps = 1; while (!q.empty()) { auto size = q.size(); while (size--) { //从数列中取出来一个数进行比对 auto cur = q.front(); q.pop(); //只要和不超过目标值就一直平方数相加求和，并把新的结果记录下来。 for (int i = 1; i * i + cur &lt;= n; i++) { //对这一层的结果进行遍历 auto newResult = i * i + cur; //发现符合题目要求的结果，返回层数 if (newResult == n) { return steps; } //如果已存进去的数不包含这个数就把它存进去 if (!visited.count(newResult)) { visited.insert(newResult); q.push(newResult); } } } //每过完一层，层数加1 steps++; } return -1; // should never reach here. } }; 127.最短单词路径 Leetcode / 力扣 Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] Output: 5 Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, return its length 5. Input: beginWord = &quot;hit&quot; endWord = &quot;cog&quot; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Output: 0 Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。 class Solution { public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { //定义一个纪录单词序列的set集合 unordered_set&lt;string&gt; wordSet(wordList.begin(),wordList.end());//注意此处不加等于号 //如果单词序列没有目标单词直接返回false if(wordSet.find(endWord) == wordSet.end()){ return 0; } //定义一个记录已访问序列的集合 unordered_map&lt;string,int&gt; verifiedWord; //定义一个队列用来进行BFS，并把第一个单词放进去 queue&lt;string&gt; q; q.push(beginWord); //往已记录序列放入第一个元素,步幅记录为1 verifiedWord.insert(pair&lt;string,int&gt;(beginWord,1)); //以下开始进行广度优先搜索 while(!q.empty()){ //只要队列里有元素就一直搜索 //把队列的第一个元素取出来 string word = q.front(); //弹出元素 q.pop(); //记录当前层次所需要的步数 int path = verifiedWord[word]; //以下根据本题需求定制化处理 for(int i = 0;i &lt; word.size();i++){ //依次替换取出来单词的位置 for(int j = 0;j &lt; 26;j++){ string newWord = word; newWord[i] = j+'a'; //如果这个单词和目标单词一样则返回 if(newWord == endWord){ return path+1; } //这个新替换的单词之前没有出现过并且队列里存在这个单词 if(wordSet.find(newWord)!= wordSet.end()&amp;&amp; verifiedWord.find(newWord) == verifiedWord.end()){ //把这个新单词加入已验证集合中 verifiedWord.insert(pair&lt;string,int&gt;(newWord,path+1)); //把这个新词加入队列中 q.push(newWord); } } } } //如果走完了找不到目标，则返回0 return 0; } }; 每次从单词队列里面取出来一个单词，然后拼凑到一起，如果是新的单词并且出现在要求队列里面则把这个拼凑的单词放到数组中，如果拼凑的单词不属于目标队列则删除。遍历存入的队列的不同层次，最先遇到目标单词的必定是最短的路径。 ","link":"https://sugar940.github.io/post/bfs-guang-du-you-xian-sou-suo-he-ji/"},{"title":"分治思想合集","content":"244.为运算符设置优先级 Leetcode / 力扣 Input: &quot;2-1-1&quot;. ((2-1)-1) = 0 (2-(1-1)) = 2 Output : [0, 2] class Solution { public: vector&lt;int&gt; diffWaysToCompute(string expression) { vector&lt;int&gt;count; //采用分治思想求解，把每一个段分为独立的小个体最终集合为大个体 for(int i = 0;i&lt;expression.size();i++){ char c = expression[i]; if(c == '+'||c == '-'|| c == '*'){ //分治 //将字符串划分为左右两部分 vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0,i)); vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i+1)); for(int &amp;l:left){ for(int &amp;r:right){ switch(c){ case '+': count.push_back(r+l); break; case '-': count.push_back(l-r); break; case '*': count.push_back(l*r); break; } } } } } if(count.size()==0){ //单个数字 count.push_back(stoi(expression)); } return count; } }; 思想： 采用分治法，本题其实就是要遍历讨论所有括号的情况，可以采用分治法，把一段才分成左右两部分。每次对这两部分进行符号运算，然后返回运算后的结果，同时每一个运算之中又把要运算的段分成两部分，一次不断拆分，直到划分为两个没有符号的数字，此处作为分治法的终点，然后以此不断返回断的值。由此得到正确答案。 95.不同的二叉树 Leetcode / 力扣 给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。 Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;TreeNode*&gt; generateTrees(int start,int end){ if(start &gt; end){ return {NULL};//注意这里要以数组的形式返回 } vector&lt;TreeNode*&gt; allTrees; for(int i = start;i &lt;= end;i++){ //分治 //把树划分成左右子树，分治运算 vector&lt;TreeNode*&gt; leftTree = generateTrees(start,i-1); vector&lt;TreeNode*&gt; rightTree = generateTrees(i+1,end); for(auto &amp;left:leftTree){ for(auto &amp;right:rightTree){ TreeNode* currTree = new TreeNode(i); currTree-&gt;left = left; currTree-&gt;right = right; allTrees.push_back(currTree); } } } return allTrees; } vector&lt;TreeNode*&gt; generateTrees(int n) { if (!n) { return {}; } return generateTrees(1, n); } }; 思想：此题同样采用分治，把多种树的组合看成一个结点的左右分别安装不同的树的问题。采用分治法，把一颗树分为左右两个结点，而左右两个结点之中又包含它的左右两个结点，以此不停划分，直到需要划分的结点没有子结点时到达终点，并由此返回结点，最终把各种树的情况构建出来。 ","link":"https://sugar940.github.io/post/fen-zhi-si-xiang-he-ji/"},{"title":"二分查找合集","content":"69.求开方 Leetcode / 力扣 Input: 4 Output: 2 Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated. 一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。 class Solution { public: int mySqrt(int x) { if(x&lt;=1){ return x; } int left = 1; int right = x;//一个数的平方根不会超过它的一半 int mid; while(left &lt;= right){ mid = left+(right-left)/2; //如果中间值的平方比目标值大，说明范围应该缩小 //此处用除法避免乘法溢出 if(mid == x/mid){ return mid; }else if(mid &gt; x/mid){ right = mid-1; }else{ left = mid + 1; } } return right;//循环结束时右边总是比左边小1，此题要求向下取整故取右边 } }; 744.大于给定元素的最小元素 Leetcode / 力扣 Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot; 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。 class Solution { public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) { int left = 0; int right = letters.size()-1; int mid; while(left &lt;= right){ mid = left+(right-left)/2; //值大了，需要缩小区域 if(letters[mid] &gt; target){//此处要注意是&gt;，不是&gt;=。因为小于等于在本题中都是要被抛弃的，要放在一起。 right = mid-1; }else{ left = mid+1; } } return left&lt;letters.size()?letters[left]:letters[0]; } }; 540.有叙述组的Single Element Leetcode / 力扣 Input: [1, 1, 2, 3, 3, 4, 4, 8, 8] Output: 2 题目描述：一个有序数组只有一个数不出现两次，找出这个数。 要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。 class Solution { public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { //观察数组可知唯一的数会改变数组成双成对的状态。 //目标点的前半段nums[m] == nums[m+1],目标点范围[m+2,h] //目标点多后半段nums[m] != nums[m+1],目标点范围[l,m] //注意此处把m的坐标统一为分组的第一个数，即数组中的偶数坐标。 int l = 0; int h = nums.size()-1; int m; while(l &lt; h){ m = l + (h-l)/2; //统一为偶数 if(m % 2 == 1){ m = m-1; } if(nums[m] == nums[m+1]){ //在前半段中 //故往后缩小范围 l = m+2; }else if(nums[m] != nums[m+1]){ //在后半段中 //往前缩小范围 h = m; } } return nums[l]; } }; 解题思路 由题目知该数组必定是奇数的数组，该题目可以转换成寻找非双胞胎的组合，即目标值之前的数组两两成对，目标值之后的数组两两不成对（起始坐标为偶数坐标0，2....)。 所以可以分解为以下步骤： 1、中间值取偶数位 2、中间值和后面的数两两成对：目标值在后面 3、中间值和后面的数两两不成对：目标值在前面 4、由于数组中必定存在目标值，所以此处不需要讨论l&lt;h的情况。 278.第一个错误版本 Leetcode / 力扣 题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。 如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。 因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。 public int firstBadVersion(int n) { int l = 1, h = n; while (l &lt; h) { int mid = l + (h - l) / 2; if (isBadVersion(mid)) { h = mid; } else { l = mid + 1; } } return l; } // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int left = 0; int right = n; while(left &lt; right){ int mid = left + (right-left)/2; if(isBadVersion(mid)){ //错误版本在左边 right = mid; }else{ //错误版本在右边 left = mid+1; } } return left; } }; 思路： 1、mid指向的数不是错误版本：错误版本在后面 2、mid指向的数是错误版本：错误版本在前面 3、本题中必有错误版本：left&lt;right即可 4、right指向的有可能是错误版本的根源也可能不是根源，所以mid应该等于right，而left指向的必定不是错误版本，所以left=mid+1. 153.寻找旋转排序的最小值 Leetcode / 力扣 Input: [3,4,5,1,2], Output: 1 class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int left = 0; int right = nums.size()-1; int mid; while(left &lt; right){ mid = left+(right-left)/2; if(nums[mid] &lt; nums[right]){ //说明目标值在左侧 right = mid; }else{ //说明目标值在右侧 left = mid+1; } } return nums[left]; } }; 思路： 观察数组可以知道，经过旋转的数组，旋转点之后的数总是比旋转点之前的数要小，所以只要判断最右边的数和中间值的数的大小情况就可以知道旋转点的位置。 1、最右边的数比中间值小或相等：旋转点一定在中间值后面。 2、最右边的数比中间值大：旋转点在中间值前面或者中间值就是旋转点。 34.在排序数组中查找元素的第一个和最后一个位置 Leetcode / 力扣 Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] 题目描述：给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。 class Solution { public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size()-1; vector&lt;int&gt;ans; //返回最左侧的目标值 while(left &lt; right){ int mid = left + (right-left)/2; if(nums[mid] &lt; target){ //目标值在右侧 left = mid+1; }else if(nums[mid] &gt;= target){ //目标值在左侧 right = mid; } } int start = left; //从最左侧开始遍历 while(left &lt; nums.size() &amp;&amp; nums[left] == target){ left++; } if(start &gt; left-1){ ans.push_back(-1); ans.push_back(-1); return ans; }else{ ans.push_back(start); ans.push_back(left-1); return ans; } } }; 思路：先找到最左侧的数值，再从该数值开始往后遍历看看最后一个数在哪里。 1、中间值比目标值要小：目标值一定在中间值右侧 2、中间值不比目标值小：目标值就是中间值或者目标值在中价值左侧 ","link":"https://sugar940.github.io/post/er-fen-cha-zhao-he-ji/"},{"title":"贪心算法合集","content":"452.射气球最少飞镖 Leetcode / 力扣 Input: [[10,16], [2,8], [1,6], [7,12]] Output: 2 题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。 也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。 class Solution { public: static bool cmp(vector&lt;int&gt; &amp;a,vector&lt;int&gt;&amp;b){ return a[1] &lt; b[1]; } int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { //如果有n个不重叠的区间，那么就至少需要n个箭头去刺穿 //该问题等价于求不重叠区间的个数的问题,唯一的区别在于此处应该是大于，因为边界也包括在内。 if(points.size() == 0){ return 0; } sort(points.begin(),points.end(),cmp); int right_Max = points[0][1]; int counts = 1; for(int i = 0; i &lt; points.size();i++){ if(points[i][0] &gt; right_Max){ ++counts; right_Max = points[i][1]; } } return counts; } }; 406.根据身高按要求排队 Leetcode / 力扣 Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。 为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。 身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。 class Solution { public: static bool cmp(vector &lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b){ if(a[0] == b[0]) return a[1] &lt; b[1];//身高相同的情况下k小的在前面，因为大的只可能是前面包括和自己一样的数 return a[0]&gt;b[0]; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { vector&lt;vector&lt;int&gt;&gt; ans; if(people.size() == 0){ return ans; } sort(people.begin(),people.end(),cmp); int pos; for(int i = 0;i &lt; people.size();i++){ pos = people[i][1]; ans.insert(ans.begin()+pos,people[i]); } return ans; } }; 先将学生按照身高由高到低排序好，之后按照该顺序将学生插入队列就可以得到题目要求的结果。 因为高个子看不到矮个子，所以高个子先插入再处理矮个子（即先无视矮个子） 矮个子会受到高个子影响，所以矮个子应该在高个子后面插入。 121.炒股票收益1 Leetcode / 力扣 题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。 只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int maxBenifit = 0; int sofarMin = prices[0]; for(int i = 1;i &lt; prices.size();i++){ if(sofarMin &gt; prices[i]) sofarMin = prices[i]; else maxBenifit = max(maxBenifit,prices[i] - sofarMin); } return maxBenifit; } }; 要算最大差价，实际上就是在每一个新段之中更新最大值，也就是要找出底和顶，要是遇到新的底就更新，否则就计算差价，实时更新最大的差价。之后一定可以得到最大的差价。 122.炒股票收益2 Leetcode / 力扣 题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int ans = 0; int n = prices.size(); for (int i = 1; i &lt; n; ++i) { ans += max(0, prices[i] - prices[i - 1]); } return ans; } }; 换一个角度看，要实现总收益的最大值，实际上就是把所有正收益区间的值相加。 605.种花问题 Leetcode / 力扣 Input: flowerbed = [1,0,0,0,1], n = 1 Output: True 题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。 class Solution { public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int count = 0; for(int i = 0;i &lt; flowerbed.size();){ if(flowerbed[i] == 1){ i += 2; }else if( i == flowerbed.size()-1||flowerbed[i+1] == 0 ){//此处要注意最后一格的情况 count++; i += 2; }else{ i += 3; } } return count &gt;= n; } }; 此题的意思就是花不能连在一起种，所以我们可以从头开始模拟种花的流程，每种下一朵花就记录一下。 当一开始有花的时候，那么下一朵花只能在这一个的后面第二格种。 当后面两个没有花且此格的下一格也没有花那么此格可以种花。（它的前一个必定没有花，不然就违背了题目的规则） 若此格是最后一格，则此格必定可以种花，并且该判断条件要放在上面的判断条件之前，不然会有溢出可能。 最后如果此格的下一格有花，那么我们就往后挪三格，因为要跨过下一格。 392. 判断是否为子序列 Leetcode / 力扣 s = &quot;abc&quot;, t = &quot;ahbgdc&quot; Return true. class Solution { public: bool isSubsequence(string s, string t) { int st = 0; int tt = 0; while(st != s.size() &amp;&amp; tt!= t.size()){ if(s[st] == t[tt]){ st++; tt++; }else{ tt++; } } if(st == s.size()){ return true; }else{ return false; } } }; 可以转换为双指针问题求解。 665.把一个数组改为非递减数组 Leetcode / 力扣 Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array. 题目描述：判断一个数组是否能只修改一个数就成为非递减数组。 在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。 class Solution { public: bool checkPossibility(vector&lt;int&gt; &amp;nums) { int n = nums.size(), cnt = 0; for (int i = 0; i &lt; n - 1; ++i) { int x = nums[i], y = nums[i + 1]; if (x &gt; y) { cnt++; if (cnt &gt; 1) { return false; } if (i &gt; 0 &amp;&amp; y &lt; nums[i - 1]) { nums[i + 1] = x; } } } return true; } }; 这一题折磨了我很久，因为之前想的是找出出错的情况，当出错的时候返回false，否则返回true，但是出错的情况实在是太多了。 所以应该正着想，就顺着数组走，遇到递减的就去把它改掉，改完了继续往前走，如果还出问题就返回false。 53.子数组的最大和 Leetcode / 力扣 For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int preSum = nums[0]; int maxNum = preSum; for(int i = 1;i &lt; nums.size();i++){ preSum = preSum &gt; 0 ? preSum + nums[i] : nums[i]; maxNum = max(preSum,maxNum); } return maxNum; } }; 这一题和炒股票有点像，实际上就是收集尽可能多的正数保证和是最大的，也就是说只要加起来不是负数就有继续加下去的可能，但是要不停地去保留最大的值。但是如果加起来是负数就可以抛弃，因为这个数无论如何都会把下一个结果缩小。 763.分割字符串使得同一种字符串只在一段中出现 Leetcode / 力扣 Input: S = &quot;ababcbacadefegdehijhklij&quot; Output: [9,7,8] Explanation: The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;. This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts. class Solution { public: vector&lt;int&gt; partitionLabels(string S) { //先用map记录下每一个字母的最后位置 unordered_map&lt;int,int&gt; endPosition; for(int i = 0;i &lt; S.size();i++){ //实时更新最后位置 endPosition[S[i]] = i; } vector&lt;int&gt; ans; int begin = 0; int end = 0; //遍历数组，看对应的位置是不是最后的位置 for(int i = 0;i&lt;S.size();i++){ //始终保留段中的最后位置 end = max(end,endPosition[S[i]]); if(i == end){ ans.push_back(i-begin+1); begin = i+1; } } return ans; } }; 此题考分割字符串，同时也考察map的应用，我们要分割字符串，那么首先要知道每一段的结尾字母是谁，所以我们首先遍历数组把每一个字母最后的位置都记录下来。 之后再遍历数组，同时把每一段的最后的位置作end，每遍历一个字母就更新一次，那么最后当遍历到与end所指向位置相同的字母，它一定是这一段的末尾字母。 之后我们把这一段的长度记录下来，然后在下一段重新开始遍历。 ","link":"https://sugar940.github.io/post/tan-xin-suan-fa-he-ji/"},{"title":"荷兰国旗问题（75）","content":"题目 三指针解法 一个指针指向头，一个指针指向尾，一个指针代表进度。 进度指针每次移动判断它的值 为0的时候把对应的数值和左指针换，进度+1，左指针+1 为1的时候进度+1，即不动数组 为2的时候和右指针换，进度不变（因为还过来的可能是1也可能是0，所以进度无法准确推进，但是和左指针换的时候可以保证换过来的数只可能是1或0，因为2走过去之后2不可能在左边。所以和左指针换的时候可以进度和左指针同时+1） class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int left = 0,right = nums.size()-1; int index = 0; while(index &lt;= right){ if(nums[index] == 0){ swap(nums[left++],nums[index++]);//此处index往前走 } else if(nums[index] == 1){ index++; } else if(nums[index] == 2){ swap(nums[right--],nums[index]);//注意此处index不往前走，因为换过来的数字可能是1也可能是0需要再次判断 } } } }; ","link":"https://sugar940.github.io/post/he-lan-guo-qi-wen-ti-75/"},{"title":"无重叠区间（435) +分发饼干（455）","content":"题目 贪心算法 class Solution { public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.empty()) { return 0; } sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) { return u[1] &lt; v[1]; }); int n = intervals.size(); int right = intervals[0][1]; int ans = 1; for (int i = 1; i &lt; n; ++i) { if (intervals[i][0] &gt;= right) { ++ans; right = intervals[i][1]; } } return n - ans; } }; 题目 贪心算法 class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { int result = 0; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int gt = 0, st = 0; while(st &lt; s.size() &amp;&amp; gt &lt; g.size()){ if(g[gt] &lt;= s[st]){ ++gt; ++st; }else if(g[gt] &gt; s[st]){ st++; } } return gt; } }; ","link":"https://sugar940.github.io/post/wu-chong-die-qu-jian-435-fen-fa-bing-gan-455/"},{"title":"数组中前k个高频的字母和数字（347）（451）","content":"题目 桶排序求解 class Solution { public: //由大到小排序 static bool cmp(pair&lt;int,int&gt; &amp;a,pair&lt;int,int&gt; &amp;b){ return a.second &gt; b.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; bucket; //把相应的数值存入桶里面 //初始值为0 for(int i:nums) ++bucket[i]; vector&lt;pair&lt;int,int&gt;&gt; res(bucket.begin(),bucket.end());//把从桶的头指针至尾指针的所有数放到pair类型的vector中 //对res的头到尾的顺序进行cmp所定义的规则的排序 sort(res.begin(),res.end(),cmp); vector&lt;int&gt; ans; for(int i = 0;i &lt; k;i++){ ans.push_back(res[i].first);//注意此处不要写错了 } return ans; } }; 补充 对map型数据进行排序，可以将其放到pair型结构中，bucket.begin()包含由first和second两个元素，vector&lt;pair&lt;int,int&gt;&gt; res(bucket.begin(),bucket.end());就是把从桶的头指针至尾指针的所有数放到pair类型的vector中，之后再对vector进行排序即可。 因为map是基于pair类型实现的，所以可以直接将map放到pair型中，map.begin代表的是一个pair。 题目 桶排序解法 class Solution { public: static bool cmp(pair&lt;char,int&gt; &amp;a,pair&lt;char,int&gt; &amp;b){ return a.second &gt; b.second; } string frequencySort(string s) { unordered_map&lt;char,int&gt; bucket; for(char i : s){ bucket[i]++; } vector&lt;pair&lt;char,int&gt;&gt; res (bucket.begin(),bucket.end()); sort(res.begin(),res.end(),cmp); string ans; for(int i = 0; i &lt; res.size();i++){ for(int j = 0;j &lt; res[i].second;j++){ ans.push_back(res[i].first); } } return ans; } }; 这一题和上面一题的解法是一样的，只需要把函数的里对应的类型修改一下，并且注意最后是把所有的字符都输出而不是单独输出字母。 ","link":"https://sugar940.github.io/post/shu-zu-zhong-qian-k-ge-gao-pin-de-zi-mu/"},{"title":"最长子序列匹配（524）","content":"题目 双指针解法 思路：每次从数组中取出来一个字符串与目标字符串对比，sl指向目标字符串，tl指向取出来的子字符串，若匹配sl和tl同时加1，若不匹配++sl。经过该过程后判断tl是否和子字符串长度一样，一样则说明匹配，然后更新结果即可。 class Solution { public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { string result; int maxNum = 0; for(int i = 0;i &lt; dictionary.size();i++){ string temp = dictionary[i]; int tL = 0; int sL = 0; while(sL &lt; s.length() &amp;&amp; tL &lt; temp.length()){ if(s[sL] == temp[tL]){ ++sL; ++tL; }else{ ++sL; } } if(tL == temp.length() &amp;&amp; tL &gt;= maxNum){ if(tL &gt; maxNum){ maxNum = tL; result = temp; }else{ if(temp &lt; result){ result = temp; } } } } return result; } }; ","link":"https://sugar940.github.io/post/zui-chang-zi-xu-lie-pi-pei-524/"},{"title":"判断链表是否有环（141）","content":"题目 ! 一直没有解决的问题 当输入空串时报错。 问题代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { if(head-&gt;next == nullptr || head == nullptr){//此处一直报错,但是nullptr不就是空串吗？ return false; }else if(head-&gt;next == head){ return true; } ListNode *fast = head-&gt;next; ListNode *slow = head; while(fast != slow){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == NULL){ return false; } } return true; } }; 正确解法 使用龟兔赛跑的解法解决问题 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { if(head == nullptr || head-&gt;next == nullptr){//注意此处一定要先判断head再判断head-&gt;next，否则万一head==nullptr，那么就会报错！！！！ return false; } ListNode *fast = head-&gt;next; ListNode *slow = head; while(fast != slow){ //这一步漏了,直接判断fast即可，因为fast一定在slow前面 if(fast==nullptr || fast -&gt; next == nullptr){ return false;//到底了。 } fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } return true; } }; ","link":"https://sugar940.github.io/post/pan-duan-lian-biao-shi-fou-you-huan-141/"},{"title":"最长回文串（680）","content":"题目 错误解法 class Solution { public: bool validPalindrome(string s) { int i = 0, j = s.length() - 1; int count = 1; while (i &lt;= j) { if (s[i] == s[j]) { ++i; --j; } else if (count == 1 &amp;&amp; s[i] != s[j]) { if (s[i] == s[j - 1]) { --j; --count; } else if (s[i + 1] == s[j]) { ++i; --count; } else { return false; } } else { return false; } } return true; } }; 正确解法 核心：只要首部+1或者尾部-1其中一个可以使得答案正确，那么就符合题目要求！ class Solution { public: bool validAgain(int head,int rear,string s){ while(head &lt; rear){ if(s[head] == s[rear]){ ++head; --rear; }else{ return false; } } return true; } bool validPalindrome(string s) { int head = 0,rear = s.length()-1; while(head &lt; rear){ if(s[head] == s[rear]){ ++head; --rear; }else{ if(validAgain(head+1,rear,s)||validAgain(head,rear-1,s)){ return true; }else{ return false; } } } return true; } }; ","link":"https://sugar940.github.io/post/zui-chang-hui-wen-chuan-680/"},{"title":"找出数组中第k大的数（345）","content":"题目 快速排序解法 第27组数据发生超时！！！问题严重 即使使用随机快速排序算法进行优化仍然无法解决问题 class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { quickSort(0,nums.size()-1,nums); return nums[nums.size()-k]; } void quickSort(int left,int right,vector&lt;int&gt;&amp; nums){//这一块没有写好，注意理解一下快排的思路 if(left &lt; right){ int pos = Randpartition(left,right,nums);//接收返回的基准值 quickSort(left,pos-1,nums); quickSort(pos+1,nums.size()-1,nums);//注意这里是pos-1和pos+1 } } int Randpartition(int left,int right,vector&lt;int&gt;&amp; nums){ int p = round(1.0*rand()/RAND_MAX*(right-left)+left);//在0-1间取一个随机数，用它来乘区间得到(0,区间),对这个区间+left得到(left,right)之间的随机数 swap(p,left,nums); int temp = nums[left]; while(left &lt; right){ while(left &lt; right &amp;&amp; temp &lt;= nums[right]) right--; nums[left] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &lt;= temp) left++;//注意这里是小于等于，不是小于，为什么呢？因为如果遇到一个一样的数就卡住的话 nums[right] = nums[left]; } nums[left] = temp; return left; } void swap(int p,int left,vector&lt;int&gt; nums){ int temp = nums[left]; nums[left] = nums[p]; nums[p] = temp; } }; 后面经过排查是quickSort写错了，应该传入的数据是left和right，而不是left和nums.size()-1 快速排序解决方案 class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { quickSort(0,nums.size()-1,nums); return nums[nums.size()-k]; } void quickSort(int left,int right,vector&lt;int&gt;&amp; nums){//这一块没有写好，注意理解一下快排的思路 if(left &lt; right){ int pos = Randpartition(left,right,nums);//接收返回的基准值 quickSort(left,pos-1,nums); quickSort(pos+1,right,nums);//注意这里是pos-1和pos+1 } } int Randpartition(int left,int right,vector&lt;int&gt;&amp; nums){ //int p = round(1.0*rand()/RAND_MAX*(right-left)+left);//在0-1间取一个随机数，用它来乘区间得到(0,区间),对这个区间+left得到(left,right)之间的随机数 int p = left + (right-left)/2;//这样写可以代替取随机数的写法。 swap(nums[p],nums[left]); int temp = nums[left]; while(left &lt; right){ while(left &lt; right &amp;&amp; temp &lt;= nums[right]) --right; nums[left] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &lt;= temp) ++left;//注意这里是小于等于，不是小于，为什么呢？因为如果遇到一个一样的数就卡住的话 nums[right] = nums[left]; } nums[left] = temp; return left; } }; 堆排序解决方案 ","link":"https://sugar940.github.io/post/zhao-chu-shu-zu-zhong-di-k-da-de-shu-345/"},{"title":"平方数之和（633）","content":"题目 双指针解法 时间复杂度O(sqrt(n)) class Solution { public: bool judgeSquareSum(int c) { long head = 0; long rear = (int)sqrt(c); long sum; while(head &lt;= rear){ sum = head*head + rear*rear; if(sum &gt; c){ rear--; } if(sum &lt; c){ head++; } if(sum == c){ return true; } } return false; } }; 坑点 本题C的取值范围为2^31-1到0，所以注意要使用long来初始化头指针和尾指针，使用int有可能会发生int型溢出。 ","link":"https://sugar940.github.io/post/ping-fang-shu-zhi-he-633/"},{"title":"算法刷题日记-两数之和(167)","content":"题目 暴力解法 算法时间复杂度为O(n^2)，空间复杂度O(1) 两次遍历循环整个数组即可。 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size();i++){ for(int j = 0;j &lt; nums.size();j++){ if(nums[i] + nums[j] == target &amp;&amp; i != j){ result.push_back(i); result.push_back(j); return result; } } } return result; } }; map解法 时间复杂度O(nlog2n) 注：map.find()的时间复杂度是log2n。是基于红黑树进行查找。 利用map的映射求解，将值记录在map中，直接查询map是否有符合要求的值，有则直接返回。 思路：遍历整个数组，每次都看map中是否有对应需求的差值，有则返回，没有则添加。 注：用目标值减去数组的值得到差值，显然差值与目标值之和符合题目要求。 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; result; map&lt;int,int&gt; mp; int mTarget; for(int i = 0; i &lt; nums.size();i++){ mTarget = target - nums[i]; map&lt;int,int&gt;::iterator it = mp.find(mTarget); if(it == mp.end()){ mp[nums[i]] = i; }else{ result.push_back(mp[mTarget]); result.push_back(i); return result; } } return result; } }; 函数使用问题 map.find(type value)若找不到指定的值，会返回end，所以如果it == map.end()则说明数组中没有这个值。 双指针解法 用两个指针分别指向数组的头和尾，和为sum，当sum&gt;target时，大指针往小的移动。当sum&lt;target时，小指针往大的移动。 但是有一个前提：要求这个数组应该是一个有序的数组！在此题中此解法并不适用。 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; result; int head = 0; int rear = nums.size()-1; int sum = 0; int i = 0; while(i &lt; nums.size()){ sum = nums[head]+nums[rear]; if(sum &lt; target){ head++; } if(sum &gt; target){ rear--; } if(sum == target){ result.push_back(head); result.push_back(rear); return result; } } return result; } }; ","link":"https://sugar940.github.io/post/suan-fa-shua-ti-ri-ji-liang-shu-zhi-he/"},{"title":"排序总结","content":"插入排序 直接插入排序 折半排序 希尔排序 过程 遍历将元素插入前面的有序队列之中 在直接插入的基础上改进：通过折半查找找出要插入的位置 通过设定步长对步长内的数组进行排序，多次反复使得数组基本有序，之后使用直接插入排序 空间复杂度 O（1） O（1） O（1） 比较一个元素时间复杂度 最好（基本有序）：O（1）最坏（顺序相反）：O（n） 平均：O(nlog2n) 总体时间复杂度 O（n^2） O(n^2) 最好：O(n^(1/3))最坏：O(n^2) 稳定性 稳定 稳定 不稳定 适用性 顺序存储和链式存储 顺序存储和链式存储 仅顺序存储 特点 基本有序时效率最高，最后一趟开始之前所有元素可能都不在最终位置上 组内排序使用直接插入排序 交换排序 冒泡排序 快速排序 过程 每次找出一个最值放到队头或者队尾 不断地将待排序表进行划分，左边都比中间小，右边都比中间大直到待排序表基本有序为止 空间复杂度 O(1) 最好情况：O（log2n）最坏情况：O（n）平均：O（log2n） 比较次数 n(n-1)/2 时间复杂度 O(n^2) O(n^2) 稳定性 稳定 不稳定 特点 元素相同时不会进行交换保证了稳定性 是所有内部排序算法中平均效率最高的算法 选择排序 简单选择排序 堆排序 过程 遍历待排序表将最小（大）的放到前面，反复该过程 先建立堆（大顶堆或小顶堆），输出堆顶数据后将堆底的数据放到堆顶然后向下调整。对堆进行排序则是从堆的最后一个元素开始进行排序，向上调整之后向下调整。 空间复杂度 O(1) O(1) 比较次数 n(n-1)/2 实际情况实际分析 时间复杂度 O（n^2） O(nlog2n)（插入元素与删除元素的时间复杂度都是） 稳定性 不稳定 稳定 特点 调整时间与树高有关，树越高调整时间越长，堆可以视为一颗完全二叉树，采用顺序存储的方式且对于大顶堆的次大值一定能在根的下一层，取出堆顶元素之后用堆最后一个元素替换堆顶元素后向下调整，若只是对堆进行排序则应该从最后一个元素开始进行排序。 ","link":"https://sugar940.github.io/post/pai-xu-zong-jie/"},{"title":"图的应用","content":"最小生成树 含义 包含图的所有顶点且长度最小 Prim算法 思想：从点开始：选取一个点后选择最短路径出发，之后重复该过程，但是只会去没有去过的结点，如果最短路径指向的结点去过了则会选取另外一个路径第二短的结点，以此类推直到没有结点可以去。 Kruskal（克鲁斯卡尔）算法 思想：从边开始：每次选取最短的边，若要选取的边所连接的结点都已经被之前的边连接了，则不选取这条边而是去选取第二短的边，以此类推知道选取的边把所有的结点都连接起来就得到了最小生成树。 最短路径 Dijkstra算法 ","link":"https://sugar940.github.io/post/tu-de-ying-yong/"},{"title":"图的遍历","content":"广度优先搜索（BFS）与深度优先搜索（DFS） 性能分析 空间复杂度 BFS需要构造辅助队列：O（v） DFS需要构造辅助栈：O（v） 邻接矩阵 查找每个顶点的邻接点所需时间：O（V） 查找所有顶点的邻接点时间复杂度：O（V^2） 链接表 查找每个顶点的邻接点所需时间：O（E） 访问每个顶点的邻接点所需时间：O（V） 查找访问所有顶点的邻接点时间复杂度：O（V+E） ","link":"https://sugar940.github.io/post/tu-de-bian-li/"},{"title":"图的存储","content":"邻接矩阵法 无向图的邻接矩阵 1、一定是一个对称矩阵 2、每一行（列）的非零元素个数正好是顶点的度 有向图的邻接矩阵 1、每一行的非零元素个数对应出度 2、每一列的非零元素个数对应入度 共性 1、邻接矩阵容易确定两个点是否相连但是难以确定边数（需要逐行列遍历） 2、邻接矩阵适合存储稠密图 链接表法 存储空间 1、无向图的存储空间为顶点数加边数乘2，有向图则为顶点数加边数 特性 1、适合存储稀疏图 2、很容易找到一个顶点的所有邻边，而邻接矩阵则需要遍历一行 3、但是要确定给定的两个顶点之间是否存在边邻接矩阵则可以快速找到 4、链接表表示不唯一 手绘图 ","link":"https://sugar940.github.io/post/tu-de-cun-chu/"},{"title":"图的相关概念","content":"图的基本性质 连通图与非连通图 连通图就是每个结点之间可以同过路径到达的无向图 非连通图就是存在无法到达其他点的结点的图，如下图 强连通图 强连通图是指有向图中的任意两个结点之间可以相互到达 连通图注意要点 1、在无向连通图中，所有顶点的度之和为边数的两倍。 2、若无向图G = （V.E）中含7个顶点，则保证图G在任何情况下都是连通的，则需要的边数最少是？ 3、构成无向连通图至少需要n-1条边（树），构成有向强连通图至少需要n条边（一个单向圆环）。 4、无向图的连通分量又称作极大连通分量。 5、一个连通图的生成树是极小连通分量，是无环的。 6、具有n个顶点的图是一个环，则它有n棵生成树（去掉一个顶点就是一棵树）。 7、具有n个顶点的有向图中，每个结点最多可以有2n-2度（入度最多n-1，出度最多n-1，一共2n-2）。 8、若一个具有n个顶点，e条边的无向图是一个森林，则森林中必有多少棵树？ ","link":"https://sugar940.github.io/post/tu-de-xiang-guan-gai-nian/"},{"title":"PPT Learning Day01","content":"PPT-Learning Day01 目标 字体透明度的控制 合并中的剪除方法 步骤 1、插入字体 2、右键选中设置图片格式进行如下设置，将透明度调成50% ![image-20200711150255232](file://D:\\课件\\PPT教学\\Day01\\PPT-Learning Day01.assets/image-20200711150255232.png) 3、将其他的字体依次插入，注意透明度的设置以及大小的设置，同时将字体的位置摆放好 效果如下 4、运用合并的剪除方法，将多余的字体边边去除 选中任意多边形，将要去除的部分描出来 PS：可以按住Ctrl键滑动鼠标的滚轮将图片放大，方便描边！ 描完边之后，我们先选中字体，再按住Ctrl键选中刚刚描绘出来的图形 选中两个物体之后，在格式菜单下选中合并形状中的剪除 PS：一定要先选中字体再选中形状！！！不然会失败！！ 成功将选中的图形去掉！ PS：插入多边形也可以在格式那边直接插入 PS：剪除之后字体就变成了形状，不再是字体了！不可以进行格式的调节！ 5、插入线条，并设置格式即可 ","link":"https://sugar940.github.io/post/ppt-learning-day01/"}]}